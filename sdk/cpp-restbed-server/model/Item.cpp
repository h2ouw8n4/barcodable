/**
 * Barcodable.com API
 * Barcodable.com API
 *
 * The version of the OpenAPI document: 1.5.0
 * Contact: support@barcodable.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "Item.h"

#include <string>
#include <sstream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

Item::Item()
{
	m_Upc = "";
	m_Ean = "";
	m_Isbn = "";
	m_Asin = "";
	m_Title = "";
	m_Sku = "";
	m_Mpn = "";
	m_Part_number = "";
	m_Description = "";
	m_Brand = "";
	m_Manufacturer = "";
	m_Color = "";
	m_New_price = 0.0;
	m_Used_price = 0.0;
	m_Currency_code = "";
	m_Url = "";
	m_Company_name = "";
	m_Company_address = "";
}

Item::~Item()
{
}

std::string Item::toJsonString(bool prettyJson)
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
	return ss.str();
}

void Item::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree Item::toPropertyTree()
{
	ptree pt;
	ptree tmp_node;
	pt.put("upc", m_Upc);
	pt.put("ean", m_Ean);
	pt.put("isbn", m_Isbn);
	pt.put("asin", m_Asin);
	pt.put("title", m_Title);
	pt.put("sku", m_Sku);
	pt.put("mpn", m_Mpn);
	pt.put("part_number", m_Part_number);
	// generate tree for Upcs
	if (!m_Upcs.empty()) {
		for (const auto &childEntry : m_Upcs) {
			ptree Upcs_node;
			Upcs_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Upcs_node));
		}
		pt.add_child("upcs", tmp_node);
		tmp_node.clear();
	}
	pt.put("description", m_Description);
	pt.put("brand", m_Brand);
	pt.put("manufacturer", m_Manufacturer);
	pt.put("color", m_Color);
	pt.put("new_price", m_New_price);
	pt.put("used_price", m_Used_price);
	pt.put("currency_code", m_Currency_code);
	pt.put("url", m_Url);
	// generate tree for Features
	if (!m_Features.empty()) {
		for (const auto &childEntry : m_Features) {
			ptree Features_node;
			Features_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Features_node));
		}
		pt.add_child("features", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Dimensions
	if (!m_Dimensions.empty()) {
		for (const auto &childEntry : m_Dimensions) {
			ptree Dimensions_node;
			Dimensions_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Dimensions_node));
		}
		pt.add_child("dimensions", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Images
	if (!m_Images.empty()) {
		for (const auto &childEntry : m_Images) {
			ptree Images_node;
			Images_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Images_node));
		}
		pt.add_child("images", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Matched_items
	if (!m_Matched_items.empty()) {
		for (const auto &childEntry : m_Matched_items) {
			ptree Matched_items_node;
			Matched_items_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Matched_items_node));
		}
		pt.add_child("matched_items", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Iso_country_codes
	if (!m_Iso_country_codes.empty()) {
		for (const auto &childEntry : m_Iso_country_codes) {
			ptree Iso_country_codes_node;
			Iso_country_codes_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Iso_country_codes_node));
		}
		pt.add_child("iso_country_codes", tmp_node);
		tmp_node.clear();
	}
	pt.put("company_name", m_Company_name);
	pt.put("company_address", m_Company_address);
	// generate tree for Categories
	if (!m_Categories.empty()) {
		for (const auto &childEntry : m_Categories) {
			ptree Categories_node;
			Categories_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Categories_node));
		}
		pt.add_child("categories", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Category_hierarchies
	if (!m_Category_hierarchies.empty()) {
		for (const auto &childEntry : m_Category_hierarchies) {
			ptree Category_hierarchies_node;
			Category_hierarchies_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Category_hierarchies_node));
		}
		pt.add_child("category_hierarchies", tmp_node);
		tmp_node.clear();
	}
	return pt;
}

void Item::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	m_Upc = pt.get("upc", "");
	m_Ean = pt.get("ean", "");
	m_Isbn = pt.get("isbn", "");
	m_Asin = pt.get("asin", "");
	m_Title = pt.get("title", "");
	m_Sku = pt.get("sku", "");
	m_Mpn = pt.get("mpn", "");
	m_Part_number = pt.get("part_number", "");
	// push all items of Upcs into member vector
	if (pt.get_child_optional("upcs")) {
		for (const auto &childTree : pt.get_child("upcs")) {
			m_Upcs.emplace_back(childTree.second.data());
		}
	}
	m_Description = pt.get("description", "");
	m_Brand = pt.get("brand", "");
	m_Manufacturer = pt.get("manufacturer", "");
	m_Color = pt.get("color", "");
	m_New_price = pt.get("new_price", 0.0);
	m_Used_price = pt.get("used_price", 0.0);
	m_Currency_code = pt.get("currency_code", "");
	m_Url = pt.get("url", "");
	// push all items of Features into member vector
	if (pt.get_child_optional("features")) {
		for (const auto &childTree : pt.get_child("features")) {
			m_Features.emplace_back(childTree.second.data());
		}
	}
	// push all items of Dimensions into member vector
	if (pt.get_child_optional("dimensions")) {
		for (const auto &childTree : pt.get_child("dimensions")) {
			m_Dimensions.emplace_back(childTree.second.data());
		}
	}
	// push all items of Images into member vector
	if (pt.get_child_optional("images")) {
		for (const auto &childTree : pt.get_child("images")) {
			m_Images.emplace_back(childTree.second.data());
		}
	}
	// push all items of Matched_items into member vector
	if (pt.get_child_optional("matched_items")) {
		for (const auto &childTree : pt.get_child("matched_items")) {
			m_Matched_items.emplace_back(childTree.second.data());
		}
	}
	// push all items of Iso_country_codes into member vector
	if (pt.get_child_optional("iso_country_codes")) {
		for (const auto &childTree : pt.get_child("iso_country_codes")) {
			m_Iso_country_codes.emplace_back(childTree.second.data());
		}
	}
	m_Company_name = pt.get("company_name", "");
	m_Company_address = pt.get("company_address", "");
	// push all items of Categories into member vector
	if (pt.get_child_optional("categories")) {
		for (const auto &childTree : pt.get_child("categories")) {
			m_Categories.emplace_back(childTree.second.data());
		}
	}
	// push all items of Category_hierarchies into member vector
	if (pt.get_child_optional("category_hierarchies")) {
		for (const auto &childTree : pt.get_child("category_hierarchies")) {
			m_Category_hierarchies.emplace_back(childTree.second.data());
		}
	}
}

std::string Item::getUpc() const
{
    return m_Upc;
}
void Item::setUpc(std::string value)
{
	m_Upc = value;
}
std::string Item::getEan() const
{
    return m_Ean;
}
void Item::setEan(std::string value)
{
	m_Ean = value;
}
std::string Item::getIsbn() const
{
    return m_Isbn;
}
void Item::setIsbn(std::string value)
{
	m_Isbn = value;
}
std::string Item::getAsin() const
{
    return m_Asin;
}
void Item::setAsin(std::string value)
{
	m_Asin = value;
}
std::string Item::getTitle() const
{
    return m_Title;
}
void Item::setTitle(std::string value)
{
	m_Title = value;
}
std::string Item::getSku() const
{
    return m_Sku;
}
void Item::setSku(std::string value)
{
	m_Sku = value;
}
std::string Item::getMpn() const
{
    return m_Mpn;
}
void Item::setMpn(std::string value)
{
	m_Mpn = value;
}
std::string Item::getPartNumber() const
{
    return m_Part_number;
}
void Item::setPartNumber(std::string value)
{
	m_Part_number = value;
}
std::vector<std::string> Item::getUpcs() const
{
    return m_Upcs;
}
void Item::setUpcs(std::vector<std::string> value)
{
	m_Upcs = value;
}
std::string Item::getDescription() const
{
    return m_Description;
}
void Item::setDescription(std::string value)
{
	m_Description = value;
}
std::string Item::getBrand() const
{
    return m_Brand;
}
void Item::setBrand(std::string value)
{
	m_Brand = value;
}
std::string Item::getManufacturer() const
{
    return m_Manufacturer;
}
void Item::setManufacturer(std::string value)
{
	m_Manufacturer = value;
}
std::string Item::getColor() const
{
    return m_Color;
}
void Item::setColor(std::string value)
{
	m_Color = value;
}
double Item::getNewPrice() const
{
    return m_New_price;
}
void Item::setNewPrice(double value)
{
	m_New_price = value;
}
double Item::getUsedPrice() const
{
    return m_Used_price;
}
void Item::setUsedPrice(double value)
{
	m_Used_price = value;
}
std::string Item::getCurrencyCode() const
{
    return m_Currency_code;
}
void Item::setCurrencyCode(std::string value)
{
	m_Currency_code = value;
}
std::string Item::getUrl() const
{
    return m_Url;
}
void Item::setUrl(std::string value)
{
	m_Url = value;
}
std::vector<std::string> Item::getFeatures() const
{
    return m_Features;
}
void Item::setFeatures(std::vector<std::string> value)
{
	m_Features = value;
}
std::vector<std::shared_ptr<Object>> Item::getDimensions() const
{
    return m_Dimensions;
}
void Item::setDimensions(std::vector<std::shared_ptr<Object>> value)
{
	m_Dimensions = value;
}
std::vector<std::string> Item::getImages() const
{
    return m_Images;
}
void Item::setImages(std::vector<std::string> value)
{
	m_Images = value;
}
std::vector<std::shared_ptr<Object>> Item::getMatchedItems() const
{
    return m_Matched_items;
}
void Item::setMatchedItems(std::vector<std::shared_ptr<Object>> value)
{
	m_Matched_items = value;
}
std::vector<std::string> Item::getIsoCountryCodes() const
{
    return m_Iso_country_codes;
}
void Item::setIsoCountryCodes(std::vector<std::string> value)
{
	m_Iso_country_codes = value;
}
std::string Item::getCompanyName() const
{
    return m_Company_name;
}
void Item::setCompanyName(std::string value)
{
	m_Company_name = value;
}
std::string Item::getCompanyAddress() const
{
    return m_Company_address;
}
void Item::setCompanyAddress(std::string value)
{
	m_Company_address = value;
}
std::vector<std::string> Item::getCategories() const
{
    return m_Categories;
}
void Item::setCategories(std::vector<std::string> value)
{
	m_Categories = value;
}
std::vector<std::string> Item::getCategoryHierarchies() const
{
    return m_Category_hierarchies;
}
void Item::setCategoryHierarchies(std::vector<std::string> value)
{
	m_Category_hierarchies = value;
}

}
}
}
}

